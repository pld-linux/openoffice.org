Index: tools/bootstrp/static.mk
===================================================================
RCS file: /cvs/util/tools/bootstrp/static.mk,v
retrieving revision 1.26
diff -u -p -u -r1.26 static.mk
--- tools/bootstrp/static.mk	15 Apr 2003 17:55:11 -0000	1.26
+++ tools/bootstrp/static.mk	14 May 2003 08:02:07 -0000
@@ -146,6 +146,7 @@ STATIC_LIBS		+=	-lX11 -lXext 
 .ELSE
 STATIC_LIBS		+=	-lsupc++ -lX11 -lXext 
 .ENDIF
+STATIC_LIBS             += `pkg-config --libs gnome-vfs-2.0`
 .ENDIF
 
 # -----------------------------------------------------------
Index: tools/source/fsys/makefile.mk
===================================================================
RCS file: /cvs/util/tools/source/fsys/makefile.mk,v
retrieving revision 1.7
diff -u -p -u -r1.7 makefile.mk
--- tools/source/fsys/makefile.mk	30 Apr 2003 08:25:46 -0000	1.7
+++ tools/source/fsys/makefile.mk	14 May 2003 08:02:07 -0000
@@ -101,6 +101,8 @@ OBJFILES=   $(OBJ)$/wldcrd.obj   \
             $(OBJ)$/tdir.obj	\
             $(OBJ)$/urlobj.obj
 
+CFLAGS+=`pkg-config --cflags gnome-vfs-2.0`
+
 # --- Targets ------------------------------------------------------
 
 .INCLUDE :  target.mk
Index: tools/source/fsys/urlobj.cxx
===================================================================
RCS file: /cvs/util/tools/source/fsys/urlobj.cxx,v
retrieving revision 1.37
diff -u -p -u -r1.37 urlobj.cxx
--- tools/source/fsys/urlobj.cxx	24 Apr 2003 13:27:52 -0000	1.37
+++ tools/source/fsys/urlobj.cxx	14 May 2003 08:02:10 -0000
@@ -107,6 +107,43 @@
 #define INCLUDED_LIMITS
 #endif
 
+#ifndef _VOS_MUTEX_HXX
+#include <vos/mutex.hxx>
+#endif
+
+#include <stdio.h>
+#include <signal.h>
+
+#include <libgnomevfs/gnome-vfs.h>
+
+#undef USE_GNOME_VFS_2_2
+
+#ifdef USE_GNOME_VFS_2_2
+extern "C" {
+  GList *_gnome_vfs_configuration_get_methods_list (void);
+}
+#endif
+
+static GList *
+get_methods_list (void)
+{
+#ifdef USE_GNOME_VFS_2_2
+  return _gnome_vfs_configuration_get_methods_list ();
+#else
+  /* This sucks utterly */
+  const char *methods[] = {
+    "smb", "pipe", "ssh", "nntp", "gnome-help", "preferences", "ncp",
+    "applications", "favorites", "cdda", "system", "nfs", "camera"
+// "mailfs", "hp8", "patchfs" - broken extfs stuff ...
+  };
+  int i;
+  GList *ret = NULL;
+  for (i = 0; i < G_N_ELEMENTS (methods); i++)
+    ret = g_list_prepend (ret, (void *) methods [i]);
+  return ret;
+#endif
+}
+
 namespace unnamed_tools_urlobj {} using namespace unnamed_tools_urlobj;
 	// unnamed namespaces don't work well yet...
 
@@ -393,6 +430,8 @@ struct INetURLObject::PrefixInfo
 };
 
 //============================================================================
+static INetURLObject::SchemeInfo *vfs_schemeinfo_map = NULL;
+
 static INetURLObject::SchemeInfo const aSchemeInfoMap[INET_PROT_END]
 	= { { "", "", 0, false, false, false, false, false, false, false,
 		  false },
@@ -459,7 +498,10 @@ static INetURLObject::SchemeInfo const a
 inline INetURLObject::SchemeInfo const &
 INetURLObject::getSchemeInfo(INetProtocol eTheScheme)
 {
-	return aSchemeInfoMap[eTheScheme];
+   if (eTheScheme >= INET_PROT_END)
+     return vfs_schemeinfo_map [eTheScheme - INET_PROT_END];
+   else
+     return aSchemeInfoMap[eTheScheme];
 };
 
 //============================================================================
@@ -720,15 +762,21 @@ bool INetURLObject::setAbsURIRef(UniStri
 	// Parse <scheme>:
 	sal_Unicode const * p = pPos;
 	PrefixInfo const * pPrefix = getPrefix(p, pEnd);
+	::rtl::OString tmpStr (rTheAbsURIRef.GetBuffer (),
+			       rTheAbsURIRef.Len (),
+			       RTL_TEXTENCODING_UTF8);
+
+	//	fprintf (stderr, "setAbsURIRef '%s' %d\n", tmpStr.getStr(),
+	//		 (int) (pPrefix ? pPrefix->m_eScheme : -17));
 	if (pPrefix)
 	{
 		pPos = p;
 		m_eScheme = pPrefix->m_eScheme;
 		aSynAbsURIRef
 			= UniString::CreateFromAscii(pPrefix->m_eKind
-										         >= PrefixInfo::EXTERNAL ?
-										     pPrefix->m_pTranslatedPrefix :
-										     pPrefix->m_pPrefix);
+						     >= PrefixInfo::EXTERNAL ?
+						     pPrefix->m_pTranslatedPrefix :
+						     pPrefix->m_pPrefix);
 	}
 	else
 	{
@@ -871,6 +919,8 @@ bool INetURLObject::setAbsURIRef(UniStri
 		sal_Unicode const * pHostPortBegin = 0;
 		sal_Unicode const * pHostPortEnd = 0;
 
+//		fprintf (stderr, "Got Authority\n");
+
 		switch (m_eScheme)
 		{
 			case INET_PROT_VND_SUN_STAR_HELP:
@@ -1170,6 +1220,7 @@ bool INetURLObject::setAbsURIRef(UniStri
                          && !(m_eScheme == INET_PROT_FILE
                               && pPos != pEnd && *pPos == '/'))
 				{
+//			  fprintf (stderr, "not smart\n");
 					setInvalid();
 					return false;
 				}
@@ -1211,6 +1262,7 @@ bool INetURLObject::setAbsURIRef(UniStri
 				}
 				else if (pPos != pAuthority)
 				{
+//			  fprintf (stderr, "bogus auth\n");
 					setInvalid();
 					return false;
 				}
@@ -1290,6 +1342,7 @@ bool INetURLObject::setAbsURIRef(UniStri
 													 eEscapeType);
 						if (!INetMIME::isIMAPAtomChar(nUTF32))
 						{
+//			  fprintf (stderr, "bogus char\n");
 							setInvalid();
 							return false;
 						}
@@ -1329,14 +1382,17 @@ bool INetURLObject::setAbsURIRef(UniStri
 				case INET_PROT_LDAP:
 					if (pHostPortBegin == pPort && pPort != pHostPortEnd)
 					{
+//			  fprintf (stderr, "bogus port 0\n");
 						setInvalid();
 						return false;
 					}
 					break;
 
 				default:
-					if (pHostPortBegin == pPort)
+				        if (m_eScheme < INET_PROT_END && /* else might have a port */
+					    pHostPortBegin == pPort)
 					{
+//			  fprintf (stderr, "bogus port\n");
 						setInvalid();
 						return false;
 					}
@@ -1346,6 +1402,7 @@ bool INetURLObject::setAbsURIRef(UniStri
 			if (!parseHost(pHostPortBegin, pPort, bOctets, eMechanism, eCharset,
                            bNetBiosName, &aSynHost))
 			{
+//			  fprintf (stderr, "bogus host\n");
 				setInvalid();
 				return false;
 			}
@@ -1360,6 +1417,10 @@ bool INetURLObject::setAbsURIRef(UniStri
 		}
 	}
 
+//	::rtl::OString tmpStrPP (pPos, pEnd - pPos,
+//				 RTL_TEXTENCODING_UTF8);
+//	fprintf (stderr, "Pre path parse '%s'\n", tmpStrPP.getStr());
+
 	// Parse <path>
 	UniString aSynPath;
 	if (!parsePath(m_eScheme, &pPos, pEnd, bOctets, eMechanism, eCharset,
@@ -1368,6 +1429,7 @@ bool INetURLObject::setAbsURIRef(UniStri
 				   getSchemeInfo().m_bQuery ? '?' : 0x80000000,
 				   nFragmentDelimiter, &aSynPath))
 	{
+//	  fprintf (stderr, "Invalid path\n");
 		setInvalid();
 		return false;
 	}
@@ -1407,12 +1469,20 @@ bool INetURLObject::setAbsURIRef(UniStri
 
 	if (pPos != pEnd)
 	{
+//	  ::rtl::OString tmpStrZ (pPos, pEnd - pPos,
+//				 RTL_TEXTENCODING_UTF8);
+//	  fprintf (stderr, "Invalid fragment '%s'\n", tmpStrZ.getStr());
 		setInvalid();
 		return false;
 	}
 
 	m_aAbsURIRef = aSynAbsURIRef;
 
+//	::rtl::OString tmpStr2 (aSynAbsURIRef.GetBuffer (),
+//				aSynAbsURIRef.Len (),
+//				RTL_TEXTENCODING_UTF8);
+//	fprintf (stderr, "setAbsURIRef result '%s'\n", tmpStr2.getStr());
+
 	return true;
 }
 
@@ -1422,13 +1492,13 @@ INetURLObject INetURLObject::m_aBaseURIR
 
 //============================================================================
 bool INetURLObject::convertRelToAbs(UniString const & rTheRelURIRef,
-									bool bOctets,
-									INetURLObject & rTheAbsURIRef,
-									bool & rWasAbsolute,
-									EncodeMechanism eMechanism,
-									rtl_TextEncoding eCharset,
-									bool bIgnoreFragment, bool bSmart,
-									bool bRelativeNonURIs, FSysStyle eStyle)
+				    bool bOctets,
+				    INetURLObject & rTheAbsURIRef,
+				    bool & rWasAbsolute,
+				    EncodeMechanism eMechanism,
+				    rtl_TextEncoding eCharset,
+				    bool bIgnoreFragment, bool bSmart,
+				    bool bRelativeNonURIs, FSysStyle eStyle)
 	const
 {
 	sal_Unicode const * p = rTheRelURIRef.GetBuffer();
@@ -1443,6 +1513,11 @@ bool INetURLObject::convertRelToAbs(UniS
 	sal_uInt32 nFragmentDelimiter = '#';
 	Part ePart = PART_VISIBLE;
 
+//	if (pPrefix)
+//	  fprintf (stderr, "Got pPrefix\n");
+//	else
+//	  fprintf (stderr, "No pPrefix\n");
+
 	if (!pPrefix && bSmart)
 	{
 		// If the input matches any of the following productions (for which
@@ -1545,9 +1620,12 @@ bool INetURLObject::convertRelToAbs(UniS
 	// Fast solution for non-relative URIs:
 	if (pPrefix)
 	{
+//		fprintf (stderr, "Fast pPrefix path\n");
+
 		INetURLObject aNewURI(rTheRelURIRef, eMechanism, eCharset);
 		if (aNewURI.HasError())
 		{
+//		  fprintf (stderr, "Had error!\n");
 			rWasAbsolute = false;
 			return false;
 		}
@@ -1555,14 +1633,22 @@ bool INetURLObject::convertRelToAbs(UniS
 		if (bIgnoreFragment)
 			aNewURI.clearFragment();
 		rTheAbsURIRef = aNewURI;
+
+//		::rtl::OString tmpStr2 (m_aAbsURIRef.GetBuffer (),
+//					m_aAbsURIRef.Len (),
+//					RTL_TEXTENCODING_UTF8);
+//		fprintf (stderr, "Hard set to '%s' \n", tmpStr2.getStr());
+
 		return true;
 	}
 
+//	fprintf (stderr, "Slow non pPrefix path\n");
+
 	enum State { STATE_AUTH, STATE_ABS_PATH, STATE_REL_PATH, STATE_FRAGMENT,
 				 STATE_DONE };
 
 	UniString aSynAbsURIRef(UniString::CreateFromAscii(getSchemeInfo().
-													       m_pScheme));
+							   m_pScheme));
 	aSynAbsURIRef += ':';
 
 	sal_Char cEscapePrefix = getEscapePrefix();
@@ -2082,13 +2168,95 @@ INetURLObject::getPrefix(sal_Unicode con
 			{ "vnd.sun.star.wfs:", 0, INET_PROT_VND_SUN_STAR_WFS,
 			  PrefixInfo::OFFICIAL },
 			{ "wfs:", "vnd.sun.star.wfs:", INET_PROT_VND_SUN_STAR_WFS,
-			  PrefixInfo::ALIAS } };
-	PrefixInfo const * pFirst = aMap + 1;
-	PrefixInfo const * pLast = aMap + sizeof aMap / sizeof (PrefixInfo) - 1;
-	PrefixInfo const * pMatch = 0;
-	sal_Unicode const * pMatched = rBegin;
-	sal_Unicode const * p = rBegin;
-	xub_StrLen i = 0;
+			  PrefixInfo::ALIAS }
+		};
+
+	static GHashTable *fast_lookup = NULL;
+	int i;
+
+	if (!fast_lookup) {
+		::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+		if (!fast_lookup) {
+			// FIXME: This code should be re-factored, but C++ is
+			// broken by design for re-factoring.
+			GList *methods, *l;
+
+			fast_lookup = g_hash_table_new (g_str_hash, g_str_equal);
+	  
+			for (i = 1; i < G_N_ELEMENTS (aMap); i++) {
+				g_hash_table_insert (fast_lookup, (void *) aMap[i].m_pPrefix,
+						     (void *) (aMap + i));
+			}
+
+			methods = get_methods_list ();
+			vfs_schemeinfo_map = g_new0 (INetURLObject::SchemeInfo, g_list_length (methods));
+
+			i = INET_PROT_END;
+			for (l = methods; l; l = l->next) {
+				PrefixInfo *pi;
+				INetURLObject::SchemeInfo *si;
+				char *name;
+
+				name = g_strconcat ((gchar *) l->data, ":", NULL);
+
+				//	    g_warning ("AddV '%s'", name);
+				if (g_hash_table_lookup (fast_lookup, name)) {
+					fprintf (stderr, "Discarding URI scheme '%s'", name);
+					g_free (name);
+					continue;
+				}
+
+				pi = new PrefixInfo;
+
+				pi->m_pPrefix = (sal_Char *) name;
+				pi->m_pTranslatedPrefix = NULL;
+				pi->m_eScheme = (INetProtocol) i;
+				pi->m_eKind = PrefixInfo::OFFICIAL;
+
+				si = &vfs_schemeinfo_map [i - INET_PROT_END];
+
+				si->m_pScheme = (sal_Char *) l->data;
+				si->m_pPrefix = g_strconcat (name, "//", NULL); // what a waste
+
+				// FIXME: these are just wrong, set all to true ?
+				si->m_nDefaultPort = 0;
+				si->m_bAuthority = true;
+				si->m_bUser = false;
+				si->m_bAuth = false;
+				si->m_bPassword = false;
+				si->m_bHost = true;
+				si->m_bPort = false;
+				si->m_bHierarchical = true;
+				si->m_bQuery = false;
+
+				g_hash_table_insert (fast_lookup, (void *) pi->m_pPrefix, (void *) pi);
+				i++;
+			}
+		}
+
+		// FIXME: add write barrier when this reaches OOO_STABLE_1
+	}
+
+	char *rstr;
+
+	rstr = (char *) g_alloca (pEnd - rBegin + 2);
+	for (i = 0; i < pEnd - rBegin && rBegin [i] != ':'; i++)
+	  rstr[i] = INetMIME::toLowerCase (rBegin [i]);
+       if (i >= pEnd - rBegin) return NULL;
+	rstr [i++] = ':'; rstr [i] = '\0';
+
+	const PrefixInfo *pi;
+
+	pi = (PrefixInfo *) g_hash_table_lookup (fast_lookup, rstr);
+
+//	g_warning ("Lookup '%s' -> %d", rstr, (int) (pi ? pi->m_eScheme : -17));
+
+	if (pi)
+	  rBegin += i;
+
+	return pi;
+
+#ifdef OVER_COMPLICATED_CODE
 	for (; pFirst < pLast; ++i)
 	{
 		if (pFirst->m_pPrefix[i] == '\0')
@@ -2120,7 +2288,9 @@ INetURLObject::getPrefix(sal_Unicode con
 		}
 	}
 	rBegin = pMatched;
+
 	return pMatch;
+#endif
 }
 
 //============================================================================
@@ -2359,7 +2529,7 @@ bool INetURLObject::setHost(UniString co
 			break;
 
 		default:
-			if (aSynHost.Len() == 0)
+			if (aSynHost.Len() == 0 && m_eScheme < INET_PROT_END)
 				return false;
 			break;
 	}
@@ -2436,6 +2606,7 @@ bool INetURLObject::parsePath(INetProtoc
 				aTheSynPath = '/';
 			break;
 
+		default: /* All INET_PROT_END+ drop through here */
 		case INET_PROT_FILE:
 		case INET_PROT_VND_SUN_STAR_WFS:
 		{
@@ -3618,7 +3789,8 @@ bool INetURLObject::ConcatData(INetProto
 					break;
 
 				default:
-					if (aSynHost.Len() == 0)
+					if (aSynHost.Len() == 0 &&
+					    m_eScheme < INET_PROT_END) /* valid perhaps */
 					{
 						setInvalid();
 						return false;
Index: tools/util/makefile.mk
===================================================================
RCS file: /cvs/util/tools/util/makefile.mk,v
retrieving revision 1.10
diff -u -p -u -r1.10 makefile.mk
--- tools/util/makefile.mk	30 Apr 2003 08:25:57 -0000	1.10
+++ tools/util/makefile.mk	14 May 2003 08:02:10 -0000
@@ -200,6 +200,10 @@ SHL1STDLIBS+=   shell32.lib     \
                 uuid.lib        \
                 advapi32.lib
 .ENDIF
+.IF "$(GUI)"=="UNX"
+SHL1STDLIBS+=`pkg-config --libs gnome-vfs-2.0`
+.ENDIF
+
 
 DEF1NAME        =$(SHL1TARGET)
 DEF1DEPN = \
