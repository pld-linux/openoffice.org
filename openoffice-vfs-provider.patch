--- ucb/source/ucp/gvfs/provider.hxx	2003-04-24 16:24:35.000000000 +0100
+++ ucb/source/ucp/gvfs/provider.hxx	2003-04-24 16:24:35.000000000 +0100
@@ -0,0 +1,49 @@
+#ifndef _PROVIDER_HXX_
+#define _PROVIDER_HXX_
+
+#include <hash_set>
+
+#ifndef _RTL_REF_HXX_
+#include <rtl/ref.hxx>
+#endif
+
+#ifndef _COM_SUN_STAR_BEANS_PROPERTY_HPP_
+#include <com/sun/star/beans/Property.hpp>
+#endif
+
+#ifndef _UCBHELPER_PROVIDERHELPER_HXX
+#include <ucbhelper/providerhelper.hxx>
+#endif
+
+namespace gvfs {
+
+class ContentProvider : public ::ucb::ContentProviderImplHelper
+{
+public:
+	ContentProvider( const ::com::sun::star::uno::Reference<
+			 ::com::sun::star::lang::XMultiServiceFactory >& rSMgr );
+	virtual ~ContentProvider();
+
+	// XInterface
+	XINTERFACE_DECL()
+
+	// XTypeProvider
+	XTYPEPROVIDER_DECL()
+
+	// XServiceInfo
+	XSERVICEINFO_DECL()
+
+	// XContentProvider
+	virtual ::com::sun::star::uno::Reference<
+	  ::com::sun::star::ucb::XContent > SAL_CALL
+	queryContent( const ::com::sun::star::uno::Reference<
+		      ::com::sun::star::ucb::XContentIdentifier >& Identifier )
+		throw( ::com::sun::star::ucb::IllegalIdentifierException,
+		       ::com::sun::star::uno::RuntimeException );
+
+};
+
+}; /* namespace gvfs */
+
+#endif /* _PROVIDER_HXX_ */
+
--- ucb/source/ucp/gvfs/provider.cxx	2003-04-28 14:13:04.000000000 +0100
+++ ucb/source/ucp/gvfs/provider.cxx	2003-04-28 14:13:04.000000000 +0100
@@ -0,0 +1,208 @@
+#include <tools/urlobj.hxx>
+#include <ucbhelper/contentidentifier.hxx>
+#include <libgnomevfs/gnome-vfs-init.h>
+#include "provider.hxx"
+#include "content.hxx"
+
+using namespace com::sun::star;
+using namespace gvfs;
+
+//=========================================================================
+//=========================================================================
+//
+// ContentProvider Implementation.
+//
+//=========================================================================
+//=========================================================================
+
+ContentProvider::ContentProvider(const uno::Reference< lang::XMultiServiceFactory >& rSMgr )
+	: ::ucb::ContentProviderImplHelper( rSMgr )
+{
+}
+
+//=========================================================================
+// virtual
+ContentProvider::~ContentProvider()
+{
+}
+
+//=========================================================================
+//
+// XInterface methods.
+//
+//=========================================================================
+
+XINTERFACE_IMPL_3( ContentProvider,
+                   lang::XTypeProvider,
+                   lang::XServiceInfo,
+                   com::sun::star::ucb::XContentProvider );
+
+//=========================================================================
+//
+// XTypeProvider methods.
+//
+//=========================================================================
+
+XTYPEPROVIDER_IMPL_3( ContentProvider,
+                      lang::XTypeProvider,
+                      lang::XServiceInfo,
+                      com::sun::star::ucb::XContentProvider );
+
+//=========================================================================
+//
+// XServiceInfo methods.
+//
+//=========================================================================
+
+XSERVICEINFO_IMPL_1( ContentProvider,
+                     rtl::OUString::createFromAscii(
+			"com.sun.star.comp.GnomeVFSContentProvider" ),
+                     rtl::OUString::createFromAscii(
+			"com.sun.star.ucb.GnomeVFSContentProvider" ) );
+//=========================================================================
+//
+// Service factory implementation.
+//
+//=========================================================================
+
+ONE_INSTANCE_SERVICE_FACTORY_IMPL( ContentProvider );
+
+//=========================================================================
+//
+// XContentProvider methods.
+//
+//=========================================================================
+
+uno::Reference< com::sun::star::ucb::XContent > SAL_CALL
+ContentProvider::queryContent(
+            const uno::Reference<
+                    com::sun::star::ucb::XContentIdentifier >& Identifier )
+    throw( com::sun::star::ucb::IllegalIdentifierException,
+           uno::RuntimeException )
+{
+#ifdef DEBUG
+	g_warning ("QueryContent: '%s'", 
+		   (const sal_Char *)rtl::OUStringToOString
+		   (Identifier->getContentIdentifier(), RTL_TEXTENCODING_UTF8));
+#endif
+
+	// It sucks to depend on 'tools' but ...
+	INetURLObject url( Identifier->getContentIdentifier() );
+	if ( url.GetProtocol() < INET_PROT_END ) {
+#ifdef DEBUG
+		g_warning ("Not one of ours ... '%s'",
+			   (const sal_Char *)rtl::OUStringToOString
+			   (Identifier->getContentIdentifier(), RTL_TEXTENCODING_UTF8));
+#endif
+		throw com::sun::star::ucb::IllegalIdentifierException();
+	}
+
+    	vos::OGuard aGuard( m_aMutex );
+
+	// Check, if a content with given id already exists...
+	uno::Reference< com::sun::star::ucb::XContent > xContent
+		= queryExistingContent( Identifier ).getBodyPtr();
+	if ( xContent.is() )
+		return xContent;
+
+	try
+	{
+	        xContent = new ::gvfs::Content(m_xSMgr, this, Identifier );
+	}
+	catch ( com::sun::star::ucb::ContentCreationException const & )
+	{
+		throw com::sun::star::ucb::IllegalIdentifierException();
+	}
+
+	if ( !xContent->getIdentifier().is() )
+		throw com::sun::star::ucb::IllegalIdentifierException();
+
+	return xContent;
+}
+
+
+//============================ shlib entry points =============================================
+
+
+// cut and paste verbatim from webdav (that sucks).
+static sal_Bool
+writeInfo( void                                 *pRegistryKey,
+	   const rtl::OUString                  &rImplementationName,
+	   uno::Sequence< rtl::OUString > const &rServiceNames )
+{
+	rtl::OUString aKeyName( rtl::OUString::createFromAscii( "/" ) );
+	aKeyName += rImplementationName;
+	aKeyName += rtl::OUString::createFromAscii( "/UNO/SERVICES" );
+
+	uno::Reference< registry::XRegistryKey > xKey;
+	try {
+		xKey = static_cast< registry::XRegistryKey * >
+			(pRegistryKey )->createKey( aKeyName );
+	}
+	catch ( registry::InvalidRegistryException const & ) {
+	}
+
+	if ( !xKey.is() )
+		return sal_False;
+
+	sal_Bool bSuccess = sal_True;
+
+	for ( sal_Int32 n = 0; n < rServiceNames.getLength(); ++n ) {
+		try {
+			xKey->createKey( rServiceNames[ n ] );
+
+		} catch ( registry::InvalidRegistryException const & ) {
+			bSuccess = sal_False;
+			break;
+		}
+	}
+	return bSuccess;
+}
+
+extern "C" void SAL_CALL 
+component_getImplementationEnvironment( const sal_Char  **ppEnvTypeName,
+					uno_Environment **ppEnv )
+{
+	*ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+}
+
+extern "C" sal_Bool SAL_CALL 
+component_writeInfo( void *pServiceManager,
+		     void *pRegistryKey )
+{
+	return pRegistryKey &&
+		writeInfo( pRegistryKey,
+			   ::gvfs::ContentProvider::getImplementationName_Static(),
+			   ::gvfs::ContentProvider::getSupportedServiceNames_Static() );
+}
+extern "C" void * SAL_CALL
+component_getFactory( const sal_Char *pImplName,
+		      void           *pServiceManager,
+		      void           *pRegistryKey )
+{
+	void * pRet = 0;
+
+	{
+		osl::Guard< osl::Mutex > aGuard( osl::Mutex::getGlobalMutex() );
+		if (!gnome_vfs_initialized ())
+			gnome_vfs_init ();
+		if (!auth_queue)
+			auth_queue = g_private_new( auth_queue_destroy );
+	}
+
+	uno::Reference< lang::XMultiServiceFactory > xSMgr
+		(reinterpret_cast< lang::XMultiServiceFactory * >( pServiceManager ) );
+	uno::Reference< lang::XSingleServiceFactory > xFactory;
+
+	if ( !::gvfs::ContentProvider::getImplementationName_Static().compareToAscii( pImplName ) )
+		xFactory = ::gvfs::ContentProvider::createServiceFactory( xSMgr );
+
+	if ( xFactory.is() ) {
+		xFactory->acquire();
+		pRet = xFactory.get();
+	}
+
+	return pRet;
+}
+
+
